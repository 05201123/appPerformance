knowledge
1.顺序编程：程序中的所有事物在任意时刻都只能执行一个步骤。
2.采用并发编程的好处：（1）提高程序执行的速度
				a.多处理器下，完成程序片段。分布多个任务，从而极大的提高吞吐量。
				b.并发是提高运行在单处理器上程序的性能。
				
		      （2）为设计某些类型的程序提供更易用的模型
				a.并发提供一个重要的组织结构上的好处，使程序设计的极大的简化
				比如仿真系统，游戏界面，门，人，窗都有自己单独的任务。
				比如整个UI，上半步UI的显示，需要是一个单独的业务，下半步的UI的显示，是另外一个单独的业务。不阻塞页面，两个业务同时运行。。。
				比如消息机制
				b.通常线程能够创建更松散的耦合设计，否则，你的代码中各个部分都必须显示的关注那些通常可以由线程来处理的任务。
		      （3）二者皆存在
		      （4）不必考虑单核还是多核处理器。资源负载均衡。
		      （5）提升用户体验
3.并发的特性：
	就有可论证的确定性，但是实际上具有不可确定性。
	危险、偶发，只有自信，多疑，亲自动手，才能写出优质的多线程代码。
	了解并发，可以使你意识到明显正确的程序可能会展现出不正确的行为。

	并发必然会带来复杂，但用户体验，程序设计，资源负载均衡改进相比，就微不足道了。
4.并发问题令人困扰的一个主要原因：使用并发时需要解决问题有多个，而实现并发的方式也有多种，并且在这两者之间没有明显的映射关系，（而且通常都是模糊的界限）
因此，你必须理解所有这些问题和特例，以便有效的使用并发。

5.java的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而未每一个线程都提供时间片，使得每一个线程都会分配到数量合理的时间
去驱动它的任务。

6.Thread.yield()：执行完生命周期最重要的部分，建议执行其他重要的任务。这是一种希望，调度顺序还是在线程调度器那里。
	It is rarely appropriate to use this method. It may be useful for debugging or testing purposes, where it may help to reproduce bugs due to race conditions. 
	It may also be useful when designing concurrency control constructs such as the ones in the java.util.concurrent.locks package.

 thread.join();阻塞当前线程，直到thread线程执行完或者被中断即thead.isAlive==false时。

 thread.interrupt();中断，会给线程添加一个标识，表示线程已经中断，然而异常捕获时，将清理这个标识，所以在interruptException中，isInterrupted（）为false。

 Thread Daemon ：1.非后台线程跑完，后台线程立刻终断。setDaemon(true),即便是finnally方法也不会走，感觉就像crash一样。
                  2.后台线程中，生成的子线程，默认情况下，仍然是后台线程。

7.SingleThreadExecutor ： 1.任务按顺序执行，先进先出。
			  2.避免共享资源同步。

8.try catch 捕捉的是当前线程的异常。而不能捕获其他线程的异常。
	setUncaughtExceptionHandler(UncaughtExceptionHandler handler)，设置当前线程的未被捕捉的异常的处理情况。
	setDefaultUncaughtExceptionHandler，设置这个应用的的未被捕捉的异常的处理情况。
	当线程异常未被捕捉的情况下，先查看线程是否捕捉（setUncaughtExceptionHandler），如果没有则查看线程组是否捕捉，还没有，
	则查看系统级别是否捕捉setDefaultUncaughtExceptionHandler，如果没有，crash或者抛到控制台。


9.线程组，ThreadGroup，最好把线程组当成是一次不成功的尝试，你只要忽略它就好。

question
1.单核cpu下，并发多线程会提高执行速度吗？
	仍然会提高速度，当执行等待型任务时，如io处理（存取需要等待磁盘响应），若执行高密度的cpu运算是，多线程在执行速度上并不明显。
2.“为设计某些类型的程序提供更易用的模型”有具体例子吗？
3.Moore定律是什么？
4.并发是提高运行在单处理器上程序的性能。怎么理解？（可以解决问题1了）
	在单处理器上运行并发程序开销确实应该比程序的所有部分都顺序执行开销要大。因为其中增加了所谓上下文切换的代价（从一个任务切换到令一个任务）。表面上看，
	将程序的所有部分当成单个任务运行好像是开销更小一些，并且可以节省上下文切换到的代价。
	使这个问题，变得不同是阻塞。如果程序中的某个任务，因为该程序控制范围之外的某些条件（比如I/O）而导致不能继续执行。那么我们可以说这个任务或线程阻塞了。
	如果没有并发，则整个程序都将停止下来，直至外部条件发生变化。但是如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务仍然可以继续执行。
	因此这个程序可以继续向前执行。

	事实上，从性能的角度来看，如果没有任务会阻塞，那么在单处理器上使用并发就没有任何意义了。
5.协作多线程与抢占式的区别?
	协作：是主动让步，优点是无线程数量限制，上下文切换性能更优

6.单核，多核下，线程，进程调度的关系？

7.java线程调度器: 可以是cpu从一个线程转移到另一个线程

8.Thread.setPriority()与Process.setThreadPriority()区别？

9.后台线程生成的子线程是默认是后台线程，默认情况下子线程的priority也是和生成它的线程相等，派生线程，什么原理？

10.Runnable中，在构造器中启动线程，可能会变得很有问题，因为另一个任务可能会在构造器结束之前开始执行，这意味着该任务能够访问处于不稳定状态的对象。这是优选Executor而不是
显示的创建Thread对象的另外一个原因。？？？？不明白
	指的是在构造方法里，启动线程，如果线程去用这个类的资源的时候，由于这个对象还在new的过程中，所以，线程就会访问不稳定状态的对象。这是一个i额风险。

11.承诺升级理论：继续错误的代价由别人来承担，而承认错误的代价由自己来承担。



